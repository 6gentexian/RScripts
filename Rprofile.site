################################################################################
################################################################################
options(chmhelp=TRUE)
options(stringsAsFactors=FALSE)
options(prompt="<R> ")
options(width=120)
options(max.print=999)
options(editor="emacs")
options(java.parameters="-Xmx2g")
options(digits.secs = 4)
#options(defaultPackages = c(getOption("defaultPackages"), "tikzDevice"))
################################################################################
################################################################################

WINDOWS <- tolower(.Platform$OS.type) == "windows"

################################################################################
##	set library path so that we don't have to change things when R gets upgraded
################################################################################
if (!WINDOWS)
{
    fileSep <- '/'

    Sys.setenv(R_LIBS="/usr/lib/R/library")
    .Library.site <-"/home/edward/R_LIBS/3_1"
    .libPaths(c("/home/edward/Dropbox/R_LIBS/", .libPaths()))
    .libPaths(c("/home/edward/R_LIBS/3_1", .libPaths()))
    .Library.site <-"/home/edward/R_LIBS/3_1"

    paths = list.dirs(.libPaths()[grep("Dropbox", .libPaths())], recursive=TRUE,
                   full.names = TRUE)
    pathDirs=paths[grep('/', paths)]
    pathDirs=pathDirs[-grep('DEV', pathDirs)]
    pathDirs=pathDirs[-grep('OUTPUT', pathDirs)]

    .libPaths(c(pathDirs, .libPaths()))
    .libPaths(c("/home/edward/R_LIBS/3_1", .libPaths()))
    ###.libPaths()[-grep('suse', .libPaths())]

    if (file.exists("/home/edward/Dropbox"))
    {
    setwd("/home/edward/Dropbox")
    }
    ### ### .Library.site <-paste(.libPaths(), sep="", collapse=":")

} else {

    fileSep <- '\\'

    .Library.site <-"C:/Program Files/R/R-3.0.2/library"
    if (file.exists("C:/Praxeum"))
    {
    .libPaths(c("C:/Praxeum/Dropbox/R_LIBS",.libPaths()))
    }

    paths = list.dirs(.libPaths()[grep("Dropbox", .libPaths())], recursive=TRUE,
                    full.names = TRUE)
    pathDirs=paths[grep('/', paths)]
    pathDirs=pathDirs[-grep('DEV', pathDirs)]
    pathDirs=pathDirs[-grep('OUTPUT', pathDirs)]

    .libPaths(c(pathDirs, .libPaths()))
    .libPaths(c("C:/R_LIBS/3_1",.libPaths()))
    .Library.site <-paste(.libPaths(), sep="", collapse=":")

    if (file.exists("C:/Praxeum/Dropbox")) setwd("C:/Praxeum/Dropbox")
}
################################################################################
###            set a CRAN mirror; hard code the US repo for CRAN             ###
###            NB: CRAN can sometimes have another set of files in a         ###
###            'Recommended' Folder for any given R version                  ###
###  https://cran.r-project.org/src/contrib/verMajor.verMinor/Recommended/   ###
###  https://cran.r-project.org/src/contrib/                                 ###
################################################################################
local({ r <- getOption("repos")

    r["CRAN"]         <- "https://cran.us.r-project.org"
    r["WASHU"]        <- "https://cran.wustl.edu/"

    ## R-Forge has a few good one off things that aren't currently on CRAN
    r["RForge"]       <- "http://R-Forge.R-project.org"

    options(repos = r)
    rm(r)
})
################################################################################
if(WINDOWS)
{
  options(IDE = 'C:/Tinn-R/bin/Tinn-R.exe')
  options(use.DDE = T)
  ##############################################################################
  # THIS MAY CHANGE WITH EACH VERSION OF WINDOWS e.g. VISTA vs WINDOWS 7 etc
  .trPaths <- paste(paste(Sys.getenv('APPDATA'), '\\Tinn-R\\tmp\\', sep=''),
              c('', 'search.txt', 'objects.txt', 'file.r', 'selection.r'
              , 'block.r', 'lines.r'), sep='')
  ##############################################################################
  cls <- function(os = .Platform$OS.type)
  {
    if (os != "windows")
    {
      err = "'clearRcon' needs Windows OS to use Windows Scripting"
      cat(err, "\n")
      return(invisible(err))
    }

    tdir <- tempdir()
    fname <- paste(tdir, "\\clearRcon.vbs", sep = "")
    cat("Dim pShell\n", file = fname)
    cat("Set pShell = CreateObject(\"WScript.Shell\")\n", file = fname, append = TRUE)
    cat("pShell.AppActivate \"R Console\"\n", file = fname, append = TRUE)
    cat("pShell.SendKeys \"^L\"\n", file = fname, append = TRUE)
    cat("Set pShell = Nothing\n", file = fname, append = TRUE)
    system(paste("cscript //NoLogo", fname), minimized = TRUE)

    invisible(fname)
  }
}
################################################################################
################################################################################
.First <- function()
{
  if(WINDOWS)
  {
    ##	HAD TO INSTALL ACTIVESTATE TCL 8.5 AND INCLUDE THE FOLOOWING
    ##    SYS.SETENV STATEMENT TO GET 'trDDEInstall()'
    ##    TO RUN WITHOUT ERROR.
    ##  http://www.activestate.com/activetcl
    Sys.setenv(MY_TCLTK="C:/Tcl/bin")
    require(TinnRcom);
  }
}
################################################################################
################################################################################
.Last <- function()
{
  if(WINDOWS)
  {
    UPDATE()
  }
}
################################################################################
################################################################################

installNewPackages <- function(...)
{
  ##############################################################################
  # get names of installed packages
  systemPacks <- installed.packages(lib.loc=Sys.getenv("R_LIBS_SITE"), subarch=.Platform$r_arch)
  systemNames <- names(systemPacks[,'Package'])

  installedPacks <- installed.packages(lib.loc=Sys.getenv("R_LIBS_USER"), subarch=.Platform$r_arch)
  installedNames <- names(installedPacks[,'Package'])

  # get available package names
  availPacks <- available.packages()
  availNames <- names(availPacks[,1])

  # get names avail but not installed -- create loooong string
  # availNames first b/c we want to isolate those available, but not installed
  toInstallNames <- availNames[!availNames %in% unique(union(systemNames,installedNames))]
  toInstallPacks <- availPacks[which(availNames %in% toInstallNames),,drop=FALSE]
  ##############################################################################

  # portion it out as it can take a long time
  if (length(toInstallNames)>0)
  {
    chunk.size <- min(100, length(toInstallNames))
    chunk.ind  <- seq.int(1, length(toInstallNames), by=chunk.size)
    for (ii in seq_along(chunk.ind))
    {
      include=chunk.ind[ii]:(chunk.ind[ii]+(chunk.size-1))
      include=include[which(include <= length(toInstallNames))]

      for (jj in include)
      {
        install.packages(toInstallNames[jj], lib=Sys.getenv("R_LIBS_USER"),quiet=TRUE,Ncpus=4)
        cat('\n','\n')
      }
      rm(include)
      cat('\n','\n','\n','\n','\n')
    }
    rm(chunk.size,chunk.ind,ii)
    rm(installedPacks,installedNames,availPacks,availNames)
    rm(toInstallNames,toInstallPacks,systemPacks,systemNames)
  }
}

################################################################################
################################################################################
UpToDate <- function(...)
{
  makePackageList <- function(...)
  {
    rm(list=ls())
    packagesList <- search()
    doNotUnload  <- c(".GlobalEnv"
                    , "TempEnv"
                    , "Autoloads"
                    , "package:base"
                    , "package:utils"
                    )

    for(mm in 1:length(doNotUnload))
    {
      if (length(grep(doNotUnload[mm], packagesList)) == 0)   next
      packagesList <- packagesList[-grep(doNotUnload[mm], packagesList)]
    }

    rm(mm, doNotUnload)
    return(packagesList)
  }

  clearPackages <- function(...)
  {
    packagesList <- makePackageList()
    while (length(packagesList) > 0)
    {
      for(mm in length(packagesList):1)
      {
        tryCatch({

          detach(which(search() == packagesList[mm]), character.only=TRUE)

        }, error = function(ex) {
          cat("\nAn error was detected detaching packages.\n")
          cat("Package: ", packagesList[mm], "caused the problem \n \n")
          print(ex)
          stop("clearPackages: WHILE loop logic failed in clearPackages()\n")

       }, finally = {
          cat("\n")
        }) ## tryCatch()

      } ##  mm loop
      rm(mm)

      packagesList <- makePackageList()
      if (length(packagesList) > 0)
      {
        cat("\n***** WARNING *****\n")
        stop("clearPackages: WHILE loop logic failed in clearPackages()\n")
      }
    } ## while
    rm(packagesList)
  }


  clearPackages()
  cat('Current packages in memory: ', search(), '\n', '\n')


  if(WINDOWS)
  {
    update.packages(lib.loc=.libPaths()[1]
                    , ask="graphics", checkBuilt = TRUE, Ncpus=2)
    installNewPackages()
  } else {
    # checkBuilt: If ‘TRUE’, a package built under an earlier major.minor
    #      version of R (e.g. ‘2.14’) is considered to be ‘old’.  Use this
    #      to ensure that there's no incompats b/t 'Updates' that aren't
    #      truly updating to the current R build
    #
    #  UPDATE ROOT LIB
    cat('*****    -----  UPDATE ROOT LIB  -----     *****', '\n')
    update.packages(lib.loc=Sys.getenv("R_LIBS_SITE"), ask=FALSE, checkBuilt=TRUE, Ncpus=4)
    cat('*****    -----  END    ROOT LIB  -----     *****', '\n', '\n')

    #  UPDATE USER LIB
    cat('*****    -----  UPDATE USER LIB  -----     *****', '\n')
    update.packages(
        lib.loc = Sys.getenv("R_LIBS_USER"),
        ask = FALSE,
        oldPkgs = old.packages(lib.loc = Sys.getenv("R_LIBS_USER"),checkBuilt = TRUE),
        checkBuilt = TRUE,
        Ncpus=4
    )
    cat('*****    -----  END    USER LIB  -----     *****', '\n', '\n')

    ##  (ATTEMPT TO) INSTALL NEW PACAKGES
    cat('*****    -----  INSTALL NEW PACKAGES  -----     *****', '\n')
    #installNewPackages()
    cat('*****    -----  END     NEW PACKAGES  -----     *****', '\n', '\n')

  }
}
################################################################################

UPDATE <- function(...)
{
  if (WINDOWS)
  {
        # Load the TclTk package
        require(tcltk)

        # Create a new toplevel window
        tt <- tktoplevel()

        # Give the window a title
        tkwm.title(tt,"Update Packages?")
        # Create a variable to keep track of the state of the dialog window:
        #   If the window is active,                                            done = 0
        #   If the window has been closed using the OK button,                  done = 1
        #   If the window has been closed using the Cancel button or destroyed, done = 2
        done <- tclVar(0)

        # Create two buttons and for each one, set the value of the done variable to an appropriate value.
        OK.but   <- tkbutton(tt,text="  Update/Upgrade Packages Now  ", command=function() tclvalue(done)<-1)
        Cancel.but <- tkbutton(tt,text="   Cancel   ",command=function() tclvalue(done)<-2)

        # Place the two buttons on the same row in their assigned window (tt).
        tkgrid(OK.but, Cancel.but)

        # Capture the event "Destroy" (e.g. Alt-F4 in Windows) and when this happens, assign 2 to done.
        tkbind(tt, "<Destroy>", function() tclvalue(done)<-2)
        tkfocus(tt)

        # Do not proceed with the following code until the variable done is non-zero.
        #   (But other processes can still run, i.e. the system is not frozen.)
        tkwait.variable(done)

        # The variable done is now non-zero, so we would like to record its value before
        # destroying the window tt.  If we destroy it first, then done will be set to 2
        # because of our earlier binding, but we want to determine whether the user pressed
        # OK (i.e. see whether done is equal to 1).

        doneVal <- as.integer(tclvalue(done))
        tkdestroy(tt)

        if (oneVal==1) UpToDate()

  } else {
    cat('\n*******        ---------  UNIX ONLY  -------------   ************\n')
    UpToDate()
  }
}

################################################################################

################################################################################
load.packages <- function(package, repos=getOption("repos"), dependencies="Depends",...)
{
  if (!require(package, quietly=TRUE, character.only = TRUE))
  {
    install.packages(package, repos=repos, dependencies=dependencies, Ncpus=2,...)

    if(!require(package, quietly=TRUE, character.only = TRUE))
    {
      stop("package: ", sQuote(package), ' is needed.  Stopping')
    }
  }
}
################################################################################

################################################################################
ht <- function(DATA,...)
{
  INT <- list(...)

  if(length(INT)==1)
  {
    for (int in INT)
    {
      print(head(DATA, int))
            print(tail(DATA, int))
    }
  }

  if(length(INT)==0)
  {
    print(head(DATA))
    print(tail(DATA))
  }
}
################################################################################

################################################################################
su  <- base::summary;
h   <- utils::head;
n   <- base::names;
len <- base::length
################################################################################


################################################################################
####  TO UPDATE THE PACKAGES WITH ROOT PERMISSIONS:
####  If the system library is: 'usr/lib64/R/library'
####  Then change ownership of "" to root:wheel -R and add 'user' to 'wheel'
####  $ sudo chown -R root:wheel $R_HOME"/library"
####  $ sudo chmod -R 775 $R_HOME"/library"
################################################################################



##############################    sandbox    ###################################
# .Library.site <- file.path(chartr("\\", "/", R.home()), "site-library")
#R_LIBS="D:\\EBGFiles\\R-2.7.1\\library"
#install.packages("PortfolioAnalytics", repos="http://R-Forge.R-project.org")
#	R_LIBS sets the environemtn variable for library paths
#source("http://www.rmetrics.org/Rmetrics.R")
#   install.Rmetrics()
#===============================================================
# Tinn-R: necessary packages and functions
#===============================================================
##===============================================================
## Tinn-R: necessary packages and functions
## Tinn-R: >= 2.2.0.2 with TinnR package >= 1.0.3
##===============================================================
## Set the URL of the preferred repository, below some examples:
#options(repos='http://software.rc.fas.harvard.edu/mirrors/R/') # USA
#setRepositories(graphics = getOption("menu.graphics"), ind = NULL)
#}
#####
# custom list of packages that use customized repositories
# install.packages("PortfolioAnalytics", repos="http://R-Forge.R-project.org")
# rgarch source??
#
###check.integer <- function(N){
###    !length(grep("[^[:digit:]]", as.character(N)))
###}
###check.integer <- function(N){
###    !length(grep("[^[:digit:]]", format(N, scientific = FALSE)))
###}
###search.path <- function(fn,
###     paths = strsplit(chartr("\\", "/", Sys.getenv("RPATH")), split =
###                switch(.Platform$OS.type, windows = ";", ":"))[[1]]) {
###  for(d in paths)
###     if (file.exists(f <- file.path(d, fn)))
###        return(f)
###  return(NULL)
###}
##
####  clearPackages <- function(...)
####  {
####    packagesList <- makePackageList()
####    while (length(packagesList) > 0)
####    {
####      for(mm in length(packagesList):1)
####      {
####        tryCatch({
####          detach(grep(packagesList[mm], search()), character.only=TRUE)
####        }, error = function(ex) {
####           cat("An error was detected detaching packages.\n");
####           print(ex)
####
####       }, finally = {
####          cat("\n")
####        }) ## tryCatch()
####      } ##  detach package loop
####      rm(mm)
####
####      packagesList <- makePackageList()
####    } ## while
####  }
################################################################################
################################################################################



# %  rev.toInstallNames <- function(toInstallNames)
# %  {
# %    # get the names of the total installed packs since the last loop
# %    installedPacks_new <- installed.packages(lib.loc=Sys.getenv("R_LIBS_USER"), subarch=.Platform$r_arch)
# %    installedNames_new <- names(installedPacks_new[,'Package'])

# %    if (length(which(toInstallNames %in% installedNames_new)) > 0)
# %    {
# %      toInstallNames  <- toInstallNames[-which(toInstallNames %in% installedNames_new)]
# %    }
# %    return(toInstallNames)
# %  }


# %  ##############################################################################
# %  # get names of installed packages
# %  systemPacks <- installed.packages(lib.loc=Sys.getenv("R_LIBS_SITE"), subarch=.Platform$r_arch)
# %  systemNames <- names(systemPacks[,'Package'])

# %  installedPacks <- installed.packages(lib.loc=Sys.getenv("R_LIBS_USER"), subarch=.Platform$r_arch)
# %  installedNames <- names(installedPacks[,'Package'])

# %  # get available package names
# %  availPacks <- available.packages()
# %  availNames <- names(availPacks[,1])

# %  # get names avail but not installed -- create loooong string
# %  # availNames first b/c we want to isolate those available, but not installed
# %  toInstallNames <- availNames[!availNames %in% unique(union(systemNames,installedNames))]
# %  toInstallPacks <- availPacks[which(availNames %in% toInstallNames),,drop=FALSE]

# %  ###toInstallNames <- toInstallNames[1:sample(1:50,1)]
# %  ##1#cat('\n',1:length(toInstallNames),'\n','\n')
# %  ##############################################################################
# %  while (length(toInstallNames) >0)
# %  {
# %    END = length(toInstallNames)
# %    NCPUS <- 4
# %    minChunk <- 20

# %    # portion it out as it can take a long time
# %    chunk.size <- min(minChunk, length(toInstallNames))
# %    chunk.ind  <- seq.int(1, length(toInstallNames), by=chunk.size)
# %    ii=1

# %    #for (ii in seq_along(chunk.ind))
# %    #{
# %      include=chunk.ind[ii]:(chunk.ind[ii]+(chunk.size-1))
# %      include=include[which(include <= END)]
# %
# %      include=seq.int(head(include,1), tail(include,1), by=NCPUS)
# %      for (jj in include)
# %      {
# %        len.include = len(toInstallNames[jj:END])
# %        JJ = jj + min(NCPUS-1, len.include-1)

# %        install.packages(toInstallNames[jj:JJ], lib=Sys.getenv("R_LIBS_USER"),quiet=TRUE,Ncpus=NCPUS)
# %        cat('\nii= ',ii,'\tjj:JJ= ', jj:JJ,'\n','\n')
# %      }
# %      rm(jj,include)
# %      cat('\n','\n','\n')

# %      # regardless of whether they were installed, drop the packages that we tried
# %      # to install
# %      toInstallNames <- toInstallNames[-(1:minChunk)]

# %      toInstallNames <- rev.toInstallNames(toInstallNames)
# %
# %      # portion it out as it can take a long time
# %      #chunk.size <- min(minChunk, length(toInstallNames))
# %      #chunk.ind  <- seq.int(1, length(toInstallNames), by=chunk.size)
# %    cat('\nlen(installNames)= ',length(toInstallNames),'\n','\n')
# %    #}
# %    rm(chunk.size,chunk.ind,ii,END)
# %  }
# %    rm(availPacks,availNames)
# %    rm(toInstallNames,systemPacks,systemNames)


# %#toInstallNames=toInstallNames[1:1000]


# rm(list=ls())
# setwd("/home/edward/Dropbox/R")


# makePackageList <- function(...)
# {
#   rm(list=ls())
#   packagesList <- search()
#   doNotUnload  <- c(".GlobalEnv"
#                    , "TempEnv"
#                    , "Autoloads"
#                    , "package:base"
#                    , "package:utils"
#                    )

#   for(mm in 1:length(doNotUnload))
#   {
#     if (length(grep(doNotUnload[mm], packagesList)) == 0)   next
#     packagesList <- packagesList[-grep(doNotUnload[mm], packagesList)]
#   }

#   rm(mm, doNotUnload)
#   return(packagesList)
# }

# clearPackages <- function(...)
# {
#   packagesList <- makePackageList()
#   while (length(packagesList) > 0)
#   {
#     for(mm in length(packagesList):1)
#     {
#       tryCatch({

#         detach(which(search() == packagesList[mm]), character.only=TRUE)

#       }, error = function(ex) {
#         cat("\nAn error was detected detaching packages.\n")
#         cat("Package: ", packagesList[mm], "caused the problem \n \n")
#         print(ex)
#         stop("clearPackages: WHILE loop logic failed in clearPackages()\n")

#      }, finally = {
#         cat("\n")
#       }) ## tryCatch()

#     } ##  mm loop
#     rm(mm)

#     packagesList <- makePackageList()
#     if (length(packagesList) > 0)
#     {
#       cat("\n***** WARNING *****\n")
#       stop("clearPackages: WHILE loop logic failed in clearPackages()\n")
#     }
#   } ## while
#   rm(packagesList)
# }


#   clearPackages()
#   cat('Current packages in memory: ', search(), '\n', '\n')


#   # get names of installed packages
#   installedPacks <- installed.packages(lib.loc=Sys.getenv("R_LIBS_USER"))
#   installedNames <- names(installedPacks[,'Package'])

#   # get available package names
#   availPacks <- available.packages()
#   availNames <- names(availPacks[,1])

#   # get names avail but not installed -- create loooong string
#   # availNames first b/c we want to isolate those available, but not installed
#   toInstallNames <- availNames[!availNames %in% installedNames]
#   toInstallPacks <- availPacks[which(availNames %in% toInstallNames),,drop=FALSE]


# ###save(installedPacks,installedNames,availPacks,availNames,toInstallNames,toInstallPacks,file='tmp.RDATA')


# dependsFilter <- function(dependPacks, installedNames)
# {
#   # INPUT IS A STRING - HENCE 'LENGTH==1'' MEANS ONE ENTRY (ONE ROW) BUT
#   # COULD MEAN MANY DEPENDENCIES
#   if (length(dependPacks)==1 && !is.na(dependPacks))
#   {

#     dependPacks <- unlist(strsplit(dependPacks, ","))


#     if (length(grep("R \\(>=", dependPacks)) > 0)
#     {
#         dependPacks <- dependPacks[-grep("R \\(>=", dependPacks)]
#     }
#     if (length(grep("R\\(>=", dependPacks)) > 0)
#     {
#         dependPacks <- dependPacks[-grep("R\\(>=", dependPacks)]
#     }

#     dependPacks <- gsub("\\(>=.*\\)", "", dependPacks)
#     dependPacks = gsub(" ", "", dependPacks)
#     dependPacks = gsub("\n", "", dependPacks)

#     dependPacks = gsub("NA", "", dependPacks)
#     dependPacks = gsub(" ", "", dependPacks)
#     dependPacks <- gsub("^\\s+|\\s+$", "", dependPacks)
#     dependPacks = dependPacks[which(!is.na(dependPacks))]

#     if (any(dependPacks == ""))
#     {
#       dependPacks = dependPacks[-which(dependPacks == "")]
#     }
#     # ONLY CARE ABOUT DEPS THAT AREN'T ALREADY INSTALLED
#     if (length(dependPacks) > 0)
#     {
#         dependPacks <- dependPacks[which(!dependPacks %in% installedNames)]
#     }
#   }  ## IF one row

#   if (length(dependPacks)==1 && is.na(dependPacks))
#   {
#     dependPacks <- NULL
#   }
#   if (length(dependPacks) == 0)
#   {
#     dependPacks <- NULL
#   }

#   return(dependPacks)
# }


# dropPacks <- function(dependPacks,toInstallNames,toInstallPacks)
# {
#   ##############################################################################
#   # LOOP OVER packageName's DEPENDENCIES
#   if (length(dependPacks) > 0)
#   {

#     for (kk in dependPacks)
#     {
#       toInstallPacks <-  tryCatch({

#         install.packages(kk, lib=.libPaths()[1], quiet=TRUE, Ncpus=4)
#         ########################################################################
#         #  IF DEPENDENCY INSTALLS, REMOVE DEP NAME FROM  toInstallPacks$Package
#         #  - THE VECTOR OF PACKAGES THAT ARE TO BE INSTALLED (IF APPLICABLE)
#         cat("\tIt worked: ", paste(toInstallNames[1], ": INSTALLED DEP: ",kk), '\n')
#         if (length(which(toInstallPacks$Package == kk)) > 0)
#         {
#           toInstallPacks[[1]] <- toInstallPacks[[1]][-which(toInstallPacks$Package == kk)]
#           toInstallPacks[[2]] <- toInstallPacks[[2]][-which(toInstallPacks$Package == kk)]
#           toInstallPacks[[3]] <- toInstallPacks[[3]][-which(toInstallPacks$Package == kk)]
#         }
#         toInstallPacks

#         }, warning = function(w) {
#           cat('\t', paste(toInstallNames[1], ": dropPacks():  **WARNING**:  ",kk, ": NOT INSTALLED!"), '\n')
#           cat("\t**WARNING**:  ", toInstallPacks$Package[1], ": NOT INSTALLED!\n")
#           ######################################################################
#           # REMOVE ALL PACKAGES WITH kk AS A DEPENDENCY
#           toInstallPacks <- findPacksToDel(kk,toInstallNames,toInstallPacks)
#           ######################################################################
#           # REMOVE kk FROM THE PACKAGE LIST, toInstallPacks$Package, IF PRESENT
#           if (length(which(toInstallPacks$Package == kk)) > 0)
#           {
#             toInstallPacks[[1]] <- toInstallPacks[[1]][-which(toInstallPacks$Package == kk)]
#             toInstallPacks[[2]] <- toInstallPacks[[2]][-which(toInstallPacks$Package == kk)]
#             toInstallPacks[[3]] <- toInstallPacks[[3]][-which(toInstallPacks$Package == kk)]
#           }
#           return(toInstallPacks)

#         }, error = function(err) {
#           print(paste("MY_ERROR:  ",err))
#           stop("Data problem: dropBadDeps()")

#         }, finally = {
#             cat('\n')
#         })

#     } ## kk loop
#     rm(kk)
#   }
#   return(toInstallPacks)
# }


# getIndexFromList <- function(packageName, Llist)
# {
#   ##############################################################################
#   # INPUTS: packageName - package Name to search for
#   #         Llist - toInstallPacks$Depends - a list of dependencies. Each
#   #         element in the (potentially empty) list is a vector of strings
#   #         ex. "abd" or "asd" abc" "qwe" or ""
#   ##############################################################################
#   # Row Index From List
#   rifl <- NULL
#   for (ii in seq_along(Llist))
#   {
#     if (any(packageName %in% Llist[[ii]]))
#     {
#       rifl <- c(rifl, ii)
#     }
#   }
#   rm(ii)
#   return(rifl)
# }

# findPacksToDel <- function(kk,toInstallNames,toInstallPacks)
# {
#   rifl  <- getIndexFromList(kk, toInstallPacks$Depends)
#   rtd   <- rifl; rm(rifl)

#   ##############################################################################
#   # PROBLEM PACK(S) NAME WHOSE DEPS ARE ON ROWS 'rifl'
#   if (length(rtd) > 0)
#   {
#     pkgNames <- toInstallNames[rtd]

#     testRows <- getIndexFromList(pkgNames, toInstallPacks$Depends)
#     ############################################################################
#     # ONLY SELECT THE NEW ROWS TO DROP
#     testRows <- setdiff(testRows,rtd);        rm(pkgNames)
#     while (length(testRows) > 0)
#     {
#       rtd <- c(rtd, testRows)
#       pkgNames <- toInstallNames[testRows];   rm(testRows)
#       testRows <- getIndexFromList(pkgNames, toInstallPacks$Depends)
#       testRows <- setdiff(testRows,rtd);      rm(pkgNames)
#     }
#     rm(testRows)

#     toInstallPacks[[1]] <- toInstallPacks[[1]][-rtd]
#     toInstallPacks[[2]] <- toInstallPacks[[2]][-rtd]
#     toInstallPacks[[3]] <- toInstallPacks[[3]][-rtd]
#   }
#   rm(rtd)

#   return(toInstallPacks)
# }

# ################################################################################
# ################################################################################
# ################################################################################

#   #require(stats)
#   #zz <- file("/home/edward/Dropbox/R/update_custom.Rout", open = "wt")
#   #sink(zz); system.time(source('tmp.R')); sink()
#   #system.time(update.packages(lib.loc=Sys.getenv("R_LIBS_USER"), quiet=TRUE, ask=FALSE, checkBuilt=TRUE, Ncpus=4))
#   #sink()

# ################################################################################
# ################################################################################
# ################################################################################
# #rm(list=setdiff(ls(), c("dropPacks", "findPacksToDel", "dependsFilter","getIndexFromList")))
# #setwd("/home/edward/Dropbox/R")
# #load('tmp.RDATA')

# ##toInstallNames <- toInstallNames[101:150]
# ##toInstallPacks <- availPacks[which(availNames %in% toInstallNames),,drop=FALSE]


#   cat("\n\n\n***************************************************************\n")
#   cat("dim(toInstallPacks): ", dim(toInstallPacks), "\n")
#   cat("len(toInstallNames): ", length(toInstallNames), "\n")
#   cat("***************************************************************\n")

# rm(availNames, availPacks)
# ################################################################################
# ## PRELIM FILTER ON THE PACKAGE NAMES
# if (as.logical(length(which(toInstallPacks[,"Package",drop=F] == "")) > 0))
# {
#   toInstallPacks <- toInstallPacks[-which(toInstallPacks[,"Package",drop=F] == ""),,drop=FALSE]
# }
# if (as.logical(length(which(toInstallPacks[,"Package",drop=F] == "NA")) > 0))
# {
#   toInstallPacks <- toInstallPacks[-which(toInstallPacks[,"Package",drop=F] == "NA"),,drop=FALSE]
# }
# if (as.logical(length(which(is.na(toInstallPacks[,"Package",drop=F])) == 0)))
# {
#   toInstallPacks <- toInstallPacks[-which(is.na(toInstallPacks[,"Package",drop=F])),,drop=FALSE]
# }
# ################################################################################

# ################################################################################
# ## REDUCE DATA. CREATE A MODIFIED, MORE INCLUSIVE VERSION OF 'Depends'
# toInstallPacks <- toInstallPacks[,c('Package', 'Depends', 'Imports', 'LinkingTo'), drop=FALSE]
# ################################################################################

#   cat("\n\n\n***************************************************************\n")
#   cat("dim(toInstallPacks): ", dim(toInstallPacks), "\n")
#   cat("len(toInstallNames): ", length(toInstallNames), "\n")
#   #print(head(toInstallPacks,5))
#   cat("***************************************************************\n")

# ################################################################################
# # COMBINE THE 'Depends' AND 'Imports' AND 'LinkingTo" COLUMNS INTO A
# # CHARACTER VECTOR
# dependPacks <- paste(toInstallPacks[,'Depends',drop=FALSE]
#                    , toInstallPacks[,'Imports',drop=FALSE]
#                    , toInstallPacks[,'LinkingTo',drop=FALSE], sep=', ')

# # REDUCE RAW DATA TO FINAL DATA DIM
# toInstallPacks <- toInstallPacks[,c('Package', 'Depends'),drop=FALSE]
# ################################################################################

# ################################################################################
# # FILTER DATA AND CREATE LIST OF DEPENDENCIES
# dependPacks_strvec <- apply(matrix(dependPacks),1
#                       ,function(x) paste(dependsFilter(x, installedNames),sep=' ',collapse=' '))
# dependPacks <- apply(matrix(dependPacks_strvec),1,function(x) unlist(strsplit(x, " ")))
# ################################################################################

# ################################################################################
# # IDEA: RANK DATA ACCORDING TO THE NUMBER OF DEPENDENCIES
# #
# # CREATE LIST OF THE NUMBER OF DEPENDENCIES PER PACKAGE
# len_dependPacks <- unlist(lapply(dependPacks, length))

# toInstallPacks <- cbind(toInstallPacks[,c('Package'),drop=FALSE]
#                       , dependPacks_strvec
#                       , len_dependPacks)

# colnames(toInstallPacks) <- c("Package", "Depends", "LEN")


#   cat("\n\n\n***************************************************************\n")
#   cat("dim(toInstallPacks): ", dim(toInstallPacks), "\n")
#   cat("len(toInstallNames): ", length(toInstallNames), "\n")
#   print(head(toInstallPacks));   print(tail(toInstallPacks))
#   cat("***************************************************************\n")


# # DATA TYPE=MATRIX. CONVERT TO DATA FRAME TO ALLOW STRINGS AND NUMBERS
# toInstallPacks <- data.frame(toInstallPacks)
# toInstallPacks$LEN <- as.integer(toInstallPacks$LEN)

# ## ORDER toInstallPacks SO THAT PACKAGES WITH 0 DEPS ARE FIRST,
# ##   PACKAGES WITH 1 DEPS ARE SECOND, ETC...
# dependPacks    <- dependPacks[order(toInstallPacks$LEN)]
# toInstallPacks <- toInstallPacks[order(toInstallPacks$LEN),]


# # FINALIZED DATA
# toInstallPacks <- toInstallPacks[,c('Package', 'Depends'),drop=FALSE]
# toInstallNames <- toInstallPacks$Package
# ################################################################################

# ## B/C dependPacks IS A LIST, WE NEED TO STORE EVERYTHING IN A LIST
# toInstallPacks <- list('Package' = toInstallPacks$Package
#                       ,'Depends' = dependPacks
#                       ,'DepStr'  = toInstallPacks$Depends
#                       )
# ################################################################################
# ################################################################################

# if (all(toInstallNames == toInstallPacks$Package))
# {
#   cat("\n")
# } else {
#   cat("\n***** WARNING *****\n")
#   stop("Data problem: names(toInstallPacks) != toInstallNames")
# }

# rm(installedNames, installedPacks, dependPacks, dependPacks_strvec, len_dependPacks)
# ################################################################################

# ################################################################################
#   cat("\n\n\n***** INITIAL *****\n")
#   cat("dim(toInstallPacks): ", unlist(lapply(toInstallPacks, length)), "\n")
#   cat("len(toInstallNames): ", length(toInstallNames), "\n")
#   cat("***** INITIAL *****\n\n\n")

#   # DISPLAY NAMES AND DEPENDENCIES OF PACKS TO BE INSTALLED
#   cat("PRE::  # Pkgs to Install: ", length(toInstallNames), '\n')
#   print(head(cbind(toInstallPacks$Package, toInstallPacks$DepStr),3))
#   print(tail(cbind(toInstallPacks$Package, toInstallPacks$DepStr),3))
# ################################################################################


#   ii=1

#   while (length(toInstallNames) > 0)
#   {
#     cat("\n\n\tINSTALLING:  ", toInstallPacks$Package[1], "\n")

#       packageName <- toInstallNames[1]
#       if (!toInstallPacks$Package[1] == packageName)
#       {
#         stop("Data problem: toInstallNames[1] != toInstallPacks$Package[1]")
#       }
#       dependPacks <- toInstallPacks$Depends[which(toInstallPacks$Package[1] == packageName)]
#       dependPacks <- unlist(dependPacks)

#       ##########################################################################
#       # LOOP OVER packageName's DEPENDENCIES
#       #
#       # IF PACKAGE HAS NO DEPENDENCIES, THEN TRY AND INSTALL PACKAGES
#       #   IF PACKAGE INSTALLS:          REMOVE FROM toInstallPacks
#       #   IF PACKAGE DOES NOT INSTALL:  REMOVE ALL PACKAGES THAT HAVE THIS
#       #     PACKAGE AS A DEPENDENCY
#       #                                 REMOVE FROM toInstallPacks
#       ##########################################################################
#       if (length(dependPacks) > 0)
#       {
#         toInstallPacks <- dropPacks(dependPacks,toInstallNames,toInstallPacks)
#       }


#       # INSTALL AND REMOVE ORIGINAL PACKAGE IF ALL DEPS WERE INSTALLED ** OR **
#       # PACK HAD NO DEPS TO BEGIN WITH
#       if (length(toInstallPacks$Package) > 0)
#       {
#         if (toInstallPacks$Package[1] == packageName)
#         {
#           cat("\tINSTALLING:  ", toInstallPacks$Package[1], "*** NO DEPS / ALL DEPS INSTALLED ***\n")

#           toInstallPacks <- tryCatch({

#             install.packages(packageName, lib=.libPaths()[1], quiet=TRUE, Ncpus=4)
#             cat("\tINSTALLING:  ", toInstallPacks$Package[1], ":  INSTALLED!!\n\n")
#             toInstallPacks[[1]] <- toInstallPacks[[1]][-1]
#             toInstallPacks[[2]] <- toInstallPacks[[2]][-1]
#             toInstallPacks[[3]] <- toInstallPacks[[3]][-1]

#             toInstallPacks

#           }, warning = function(w) {

#             cat("\t**WARNING**:  ",packageName, ": NOT INSTALLED!\n")
#             if (length(getIndexFromList(packageName, toInstallPacks$Depends)) > 0)
#             {
#               # THREE STEP PROCESS:
#               # 1)  DROP ALL OBS THAT HAS packageName AS A DEPENDENCY
#               packsWBadDeps  <- toInstallPacks$Package[getIndexFromList(packageName, toInstallPacks$Depends)]
#               rtd            <- which(toInstallPacks$Package %in% packsWBadDeps)
#               toInstallPacks[[1]] <- toInstallPacks[[1]][-rtd]
#               toInstallPacks[[2]] <- toInstallPacks[[2]][-rtd]
#               toInstallPacks[[3]] <- toInstallPacks[[3]][-rtd]
#               toInstallNames      <- toInstallPacks$Package

#               # 2)  RECURSIVELY DROP ALL OBS THAT HAVE packsWBadDeps AS A DEPENDENCY
#               #     THEN DROP ALL OBS THAT THE PREVIOUS OBS AS A DEPENDENCY
#               toInstallPacks <- findPacksToDel(packsWBadDeps,toInstallNames,toInstallPacks)
#             }
#             # REM TO DROP packageName AS WELL
#             toInstallPacks[[1]] <- toInstallPacks[[1]][-1]
#             toInstallPacks[[2]] <- toInstallPacks[[2]][-1]
#             toInstallPacks[[3]] <- toInstallPacks[[3]][-1]

#             return(toInstallPacks)

#           }, error = function(err) {
#             print(paste("MY_FINAL_ERROR:  ",err))
#             stop("Data problem: if (toInstallPacks[1,1] == packageName)")

#           }, finally = {
#             cat('\n')
#           })
#         }
#       }



#       # REDEFINE INSTALLNAMES IN LIEU OF ANY ERRORS IN DL'ing DEP PACKS
#       toInstallNames=toInstallPacks$Package


#       # DISPLAY NAMES AND DEPENDENCIES OF PACKS TO BE INSTALLED
#       cat("POST::  # Pkgs to Install: ", length(toInstallNames), '\n')
#       if (length(toInstallPacks$Package) > 0)
#       {
#         print(head(cbind(toInstallPacks$Package, toInstallPacks$DepStr),2))
#         print(tail(cbind(toInstallPacks$Package, toInstallPacks$DepStr),2))
#       }

#     cat("\nii= ", ii, "\n")
#     ii=ii+1
#     rm(dependPacks, packageName)
#   } ## while



# cat("\n\n\n***** FINAL *****\n")
# cat("dim(toInstallPacks): ", ifelse(length(toInstallPacks$Package) == 0, 0, paste(unlist(lapply(toInstallPacks, length)),sep=' ',collapse=' ')), "\n")
# cat("dim(toInstallNames): ", length(toInstallNames), "\n")
# cat("***** FINAL *****\n\n\n")

# # DISPLAY NAMES AND DEPENDENCIES OF PACKS TO BE INSTALLED
# cat("FINAL::  # Pkgs to Install: ", length(toInstallNames), '\n')
# if (length(toInstallPacks$Package) > 0)
# {
#   print(head(cbind(toInstallPacks$Package, toInstallPacks$DepStr)))
#   print(tail(cbind(toInstallPacks$Package, toInstallPacks$DepStr)))
# }



# ================================================================================

# # install.packages("plyr") #run this if you don't have the package already
#  library(plyr)

# #make some example data
# dd<-data.frame(matrix(rnorm(216),72,3),c(rep("A",24),rep("B",24),rep("C",24)),c(rep("J",36),rep("K",36)))
# colnames(dd) <- c("v1", "v2", "v3", "dim1", "dim2")

# #ddply is the plyr function
# ddply(dd, c("dim1","dim2"), function(df)mean(df$v1))

# ddply(dd, c("dim1","dim2"), function(df)c(mean(df$v1),mean(df$v2),mean(df$v3),sd(df$v1),sd(df$v2),sd(df$v3)))


# ===========================

# pieces <- split(baseball[,6:9], baseball$year)

# results <- vector(“list”, length(pieces))
# names <- names(pieces)
# for(i in seq(1, length(pieces))){
# piece <- pieces[[i]]
# results[[i]] <- mean(piece)
# }

# result <- do.call(“rbind”, results




# ddply(baseball, .(year), function(df) mean(df[,6:9]))
